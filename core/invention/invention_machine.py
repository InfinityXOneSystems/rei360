"""
ğŸ§  INVENTION MACHINE - Generate novel ideas and auto-implement them

Uses Google Gemini Pro to:
1. Generate innovative product/feature ideas
2. Analyze feasibility and ROI
3. Auto-scaffold implementation
4. Track invention evolution
"""

import google.generativeai as genai
from google.cloud import firestore
from dataclasses import dataclass, asdict
from datetime import datetime
from typing import List, Dict, Optional
import json
import os
from pathlib import Path

@dataclass
class Invention:
    """An invention/idea generated by the machine"""
    id: str
    title: str
    description: str
    category: str  # "feature", "product", "optimization", "innovation"
    feasibility_score: float  # 0-1
    impact_score: float  # 0-1
    roi_estimate: float  # Expected ROI %
    confidence: float  # How confident is the AI in this idea
    implementation_plan: Dict
    generated_at: datetime
    status: str  # "idea", "validated", "implementing", "completed"
    auto_buildable: bool  # Can this be auto-built?


class InventionMachine:
    """AI-powered invention and innovation engine"""

    def __init__(self, gemini_api_key: str = None, project_id: str = None):
        """Initialize the Invention Machine"""

        # Setup Gemini
        api_key = gemini_api_key or os.getenv('GEMINI_API_KEY')
        if not api_key:
            raise ValueError("GEMINI_API_KEY required")

        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-pro')

        # Setup Firestore
        self.db = firestore.Client(project=project_id) if project_id else None

        # Invention tracking
        self.inventions: Dict[str, Invention] = {}

    async def generate_invention(self,
                                 domain: str,
                                 problem: str = None,
                                 constraints: List[str] = None) -> Invention:
        """Generate a novel invention/innovation"""

        prompt = f"""
        You are an innovation engine. Generate a novel, high-impact invention/innovation.

        Domain: {domain}
        {f"Problem to Solve: {problem}" if problem else ""}
        {f"Constraints: {', '.join(constraints)}" if constraints else ""}

        Generate a specific, actionable invention that:
        1. Solves a real problem or creates new value
        2. Is technically feasible with current tech
        3. Has clear ROI potential
        4. Can be implemented incrementally

        Provide response as JSON with:
        {{
            "title": "Short catchy name",
            "description": "Clear 2-3 sentence description",
            "category": "feature|product|optimization|innovation",
            "why_novel": "What makes this unique/innovative",
            "target_user": "Who benefits and how",
            "feasibility_score": 0.0-1.0,
            "impact_score": 0.0-1.0,
            "roi_estimate": percentage,
            "confidence": 0.0-1.0,
            "implementation_plan": {{
                "phase_1": "First step",
                "phase_2": "Second step",
                "phase_3": "Third step",
                "estimated_hours": number,
                "tech_stack": ["tech1", "tech2"],
                "dependencies": ["dep1", "dep2"]
            }},
            "auto_buildable": true|false,
            "build_instructions": "If auto_buildable, provide step-by-step build commands"
        }}

        Be creative but practical. Think like a senior engineer + entrepreneur.
        """

        response = self.model.generate_content(prompt)
        result = json.loads(response.text)

        # Create Invention object
        invention = Invention(
            id=self._generate_id(),
            title=result['title'],
            description=result['description'],
            category=result['category'],
            feasibility_score=result['feasibility_score'],
            impact_score=result['impact_score'],
            roi_estimate=result['roi_estimate'],
            confidence=result['confidence'],
            implementation_plan=result['implementation_plan'],
            generated_at=datetime.utcnow(),
            status="idea",
            auto_buildable=result.get('auto_buildable', False)
        )

        # Store
        self.inventions[invention.id] = invention
        if self.db:
            self.db.collection('inventions').document(invention.id).set(asdict(invention))

        return invention

    async def generate_invention_batch(self,
                                       domain: str,
                                       count: int = 10,
                                       filter_threshold: float = 0.7) -> List[Invention]:
        """Generate multiple inventions and rank by potential"""

        inventions = []

        for i in range(count):
            try:
                invention = await self.generate_invention(domain)

                # Calculate overall score
                overall_score = (
                    invention.feasibility_score * 0.3 +
                    invention.impact_score * 0.4 +
                    (invention.roi_estimate / 100) * 0.2 +
                    invention.confidence * 0.1
                )

                if overall_score >= filter_threshold:
                    inventions.append(invention)

            except Exception as e:
                print(f"Invention {i+1} failed: {e}")
                continue

        # Sort by overall potential
        inventions.sort(key=lambda x: (
            x.feasibility_score * x.impact_score * x.confidence
        ), reverse=True)

        return inventions

    async def validate_invention(self, invention_id: str) -> Dict:
        """Deep validation of an invention"""

        invention = self.inventions.get(invention_id)
        if not invention:
            raise ValueError(f"Invention {invention_id} not found")

        prompt = f"""
        Perform deep technical and business validation:

        INVENTION:
        Title: {invention.title}
        Description: {invention.description}
        Category: {invention.category}

        VALIDATE:
        1. Technical Feasibility (detailed analysis)
        2. Market Demand (who wants this?)
        3. Competitive Analysis (does this exist?)
        4. Risk Assessment (what could go wrong?)
        5. ROI Validation (is the estimate realistic?)
        6. Implementation Complexity (time/resources)

        Provide JSON:
        {{
            "validation_score": 0.0-1.0,
            "technical_feasibility": "analysis",
            "market_demand": "analysis",
            "competitive_analysis": "analysis",
            "risks": ["risk1", "risk2"],
            "validated_roi": percentage,
            "recommendation": "PROCEED|REVISE|ABANDON",
            "reasons": ["reason1", "reason2"]
        }}
        """

        response = self.model.generate_content(prompt)
        validation = json.loads(response.text)

        # Update invention status
        if validation['recommendation'] == 'PROCEED':
            invention.status = 'validated'

        return validation

    async def auto_build(self, invention_id: str) -> Dict:
        """Automatically build an invention if possible"""

        invention = self.inventions.get(invention_id)
        if not invention:
            raise ValueError(f"Invention {invention_id} not found")

        if not invention.auto_buildable:
            return {
                "success": False,
                "reason": "Invention marked as not auto-buildable"
            }

        # Generate build plan
        prompt = f"""
        Generate complete build instructions for this invention:

        Title: {invention.title}
        Description: {invention.description}
        Implementation Plan: {json.dumps(invention.implementation_plan, indent=2)}

        Generate EXACT executable commands/code to build this, including:
        1. File structure (directories and files to create)
        2. Code for each file (full implementation)
        3. Installation commands
        4. Configuration steps
        5. Testing commands
        6. Deployment commands

        Format as JSON:
        {{
            "file_structure": {{
                "path/to/file.py": "full file content",
                "path/to/another.py": "full file content"
            }},
            "install_commands": ["command1", "command2"],
            "config_steps": ["step1", "step2"],
            "test_commands": ["test1", "test2"],
            "deploy_commands": ["deploy1", "deploy2"],
            "estimated_build_time": "X minutes"
        }}

        Be extremely specific and executable.
        """

        response = self.model.generate_content(prompt)
        build_plan = json.loads(response.text)

        # Store build plan
        if self.db:
            self.db.collection('build_plans').document(invention_id).set(build_plan)

        return {
            "success": True,
            "build_plan": build_plan,
            "invention_id": invention_id
        }

    def _generate_id(self) -> str:
        """Generate unique invention ID"""
        from uuid import uuid4
        return f"inv_{uuid4().hex[:12]}"

    def get_top_inventions(self, limit: int = 10) -> List[Invention]:
        """Get top-ranked inventions"""

        inventions = list(self.inventions.values())
        inventions.sort(
            key=lambda x: x.feasibility_score * x.impact_score * x.confidence,
            reverse=True
        )

        return inventions[:limit]

    async def invention_report(self) -> str:
        """Generate invention summary report"""

        total = len(self.inventions)
        by_category = {}
        by_status = {}
        avg_roi = 0
        auto_buildable = 0

        for inv in self.inventions.values():
            by_category[inv.category] = by_category.get(inv.category, 0) + 1
            by_status[inv.status] = by_status.get(inv.status, 0) + 1
            avg_roi += inv.roi_estimate
            if inv.auto_buildable:
                auto_buildable += 1

        avg_roi = avg_roi / total if total > 0 else 0

        report = f"""
        ğŸ§  INVENTION MACHINE REPORT
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        Total Inventions: {total}
        Auto-Buildable: {auto_buildable} ({auto_buildable/total*100:.1f}%)
        Average ROI: {avg_roi:.1f}%

        By Category:
        {chr(10).join(f'  â€¢ {k}: {v}' for k, v in by_category.items())}

        By Status:
        {chr(10).join(f'  â€¢ {k}: {v}' for k, v in by_status.items())}

        Top 5 Inventions:
        """

        for i, inv in enumerate(self.get_top_inventions(5), 1):
            report += f"""
        {i}. {inv.title}
           Category: {inv.category}
           Impact: {inv.impact_score:.2f} | ROI: {inv.roi_estimate:.1f}%
           Status: {inv.status}
           Auto-Build: {'Yes' if inv.auto_buildable else 'No'}
            """

        return report


# Quick test
if __name__ == "__main__":
    import asyncio

    async def demo():
        machine = InventionMachine()

        print("ğŸ§  Generating inventions for Real Estate AI...")

        # Generate inventions
        inventions = await machine.generate_invention_batch(
            domain="Real Estate Intelligence Platform",
            count=5
        )

        print(f"\nâœ… Generated {len(inventions)} inventions!\n")

        for i, inv in enumerate(inventions, 1):
            print(f"{i}. {inv.title}")
            print(f"   {inv.description}")
            print(f"   ROI: {inv.roi_estimate:.1f}% | Impact: {inv.impact_score:.2f}")
            print(f"   Auto-Build: {'âœ…' if inv.auto_buildable else 'âŒ'}\n")

        # Generate report
        report = await machine.invention_report()
        print(report)

    asyncio.run(demo())
